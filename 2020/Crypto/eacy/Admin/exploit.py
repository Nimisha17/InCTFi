from gmpy2 import *
from hashlib import *
import random, string
from pwnlib.util.iters import mbruteforce
import re, codecs
import ecc
from Crypto.Util.number import *
from pwn import *
from tqdm import *

#=============================================================================
# POW solver w/ multi-threaded bruteforce v1.2
#=============================================================================

def bruteforce(suffix, digest):
    """
    Multithreaded POW solver for custom challenge designs
    INPUT:
    @partial: bytes
    @digest: str

    OUTPUT:
    X: sha256(X + suffix).hexdigest() == digest
    """
    return mbruteforce(
        lambda x: hashlib.sha256(x.encode() + suffix).hexdigest() == digest,
        string.ascii_letters + string.digits,
        length=4,
        method="fixed"
    )


def pow_handler():
    """
    Handler function to parse, and solve POW challenges
    """
    global io

    data = str(io.recv())
    suffix = re.search(r"[\w]{16}", data).group().encode()
    digest = re.search(r"[\w]{64}", data).group()
    prefix = bruteforce(suffix, digest)
    if io.can_recv(): io.recv()
    io.sendline(prefix)

def modular_sqrt(a, p):

    def legendre_symbol(a, p):
        
        ls = pow(a, (p - 1) // 2, p)
        return -1 if ls == p - 1 else ls

    # Simple cases
    #
    if legendre_symbol(a, p) != 1:
        return 0
    elif a == 0:
        return 0
    elif p == 2:
        return p
    elif p % 4 == 3:
        return pow(a, (p + 1) // 4, p)

    # Partition p-1 to s * 2^e for an odd s (i.e.
    # reduce all the powers of 2 from p-1)
    #
    s = p - 1
    e = 0
    while s % 2 == 0:
        s //= 2
        e += 1

    # Find some 'n' with a legendre symbol n|p = -1.
    # Shouldn't take long.
    #
    n = 2
    while legendre_symbol(n, p) != -1:
        n += 1

    x = pow(a, (s + 1) // 2, p)
    b = pow(a, s, p)
    g = pow(n, s, p)
    r = e

    while True:
        t = b
        m = 0
        for m in range(r):
            if t == 1:
                break
            t = pow(t, 2, p)

        if m == 0:
            return x

        gs = pow(g, 2 ** (r - m - 1), p)
        g = (gs * gs) % p
        x = (x * gs) % p
        b = (b * g) % p
        r = m


def find_point(ec, x):
    ysq = (x**3 + ec.a()*x + ec.b()) % ec.p()
    return modular_sqrt(ysq,ec.p())

def test_Point(x,y):
    if (y**2) % p == (x**3 + a*x + b) % p:
        return True
    else:
        return False

def find_next_e(e):
    r = long_to_bytes(e)[:-2]
    for i in trange(133,140):
        for j in  range(256):
            x = bytes_to_long(chr(i) + chr(j) + r)
            y = find_point(ec, x)
            if test_Point(x,y):
                R = ecc.Point(ec,x,y)
                r_2 = long_to_bytes((((R*inverse(d,order)).x()) *Point_Q).x())[-30:][:2]
                if long_to_bytes(e)[-2:] == r_2:
                    print "finally"
                    return R
    return R
    




st = lambda x: str(x).strip('L') 

if __name__ == "__main__":


    p = 2**256 - 2**224 + 2**192 + 2**96 - 1
    a = p-3
    b = 41058363725152142129326129780047268409114441015993725554835256314039467401291
    ec = ecc.CurveFp(p, a, b)

    _Px = 115113149114637566422228202471255745041343462839792246702200996638778690567225
    _Py = 88701990415124583444630570378020746694390711248186320283617457322869078545663
    Point_P = ecc.Point(ec, _Px, _Py)

    _Qx = 75498749949015782244392151836890161743686522667385613237212787867797557116642
    _Qy = 19586975827802643945708711597046872561784179836880328844627665993398229124361
    Point_Q = ecc.Point(ec, _Qx, _Qy)
    d = 1735
    x = 53881495764268889303293517690095107010093794097958309592680107528631746121613
    y = 69534606358473748292927094386662082099432383517498778127513290350658945146669
    
    P = ecc.Point(ec, x, y)
    Q = 123 * P


    order = 115792089210356248762697446949407573529996955224135760342422259061068512044369
    

    #io = process('./encrypt.py')
    io = remote('34.74.30.191', 3333)
    context.log_level = "debug"
    pow_handler()
    log.info("POW Completed")
    io.recvuntil("Enter your choice: ")     
    io.sendline('1')
    io.recv()
    io.sendline(st(Q.x()) + ':' + st(Q.y()))
    io.recv()
    io.sendline(st(Q.x()) + ':' + st(Q.y()))
    t = io.recvuntil('take e:  \x1b[0m')
    
    e = io.recvline().rstrip()
    e = int(e)
    print e
    log.info("Received e")
    if io.can_recv(): io.recv()
    io.sendline(st((e*123) + 123))
    io.recv()


    log.info("Forging R, S")
    R = find_next_e(e)
    S = R * invert(d,order)
    seed = S.x()
    S_1 = seed * Point_P
    r_1 = long_to_bytes((S_1.x() * Point_Q).x())[-30:]
    r_2 = long_to_bytes(((S_1.x() * Point_P).x() * Point_Q).x())[-30:][:2]
    new_e = bytes_to_long(r_1 + r_2)
    log.info("Generated new e...")

    
    log.info("Proceeding to DRBG exploit...")
    io.sendline('2')
    io.recvuntil("Enter your choice: ")
    io.sendline('2')
    print io.recv()
    io.sendline(st(Q.x()) + ':' + st(Q.y()))
    io.recv()
    io.sendline(st(Q.x()) + ':' + st(Q.y()))
    io.recvuntil('me s: ')
    io.sendline(st((new_e*123) + 123))
    print io.recvuntil('choice: ')
    io.sendline('1')
    print io.recv()
    


     
    
        

