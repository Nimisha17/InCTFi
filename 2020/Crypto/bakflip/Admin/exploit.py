#!/usr/bin/env python3

import re, codecs
import os, random, sys, string
from sage.all import *
from tqdm import *
from pwn import *
from pwnlib.util.iters import mbruteforce
from hashlib import sha1, sha256
from binascii import hexlify, unhexlify
from ecdsa import SigningKey, VerifyingKey, NIST192p
from ecdsa.numbertheory import inverse_mod
from ecdsa.ellipticcurve import PointJacobi as Point


HOST = "34.74.30.191"
PORT = 9999
io = remote(HOST, PORT)


#=============================================================================
# POW solver w/ multi-threaded bruteforce v1.2
#=============================================================================
def bruteforce(suffix: bytes, digest: str) -> str:
    """
    Multithreaded POW solver for custom challenge designs
    INPUT:
    @partial: bytes
    @digest: str

    OUTPUT:
    X: sha256(X + suffix).hexdigest() == digest
    """
    return mbruteforce(
        lambda x: hashlib.sha256(x.encode() + suffix).hexdigest() == digest,
        string.ascii_letters + string.digits,
        length = 4,
        method = "fixed"
    )


def pow_handler():
    """
    Handler function to parse, and solve POW challenges
    """
    global io

    data = str(io.recv())
    suffix = re.search(r"[\w]{16}", data).group().encode()
    digest = re.search(r"[\w]{64}", data).group()
    prefix = bruteforce(suffix, digest)
    if io.can_recv(): io.recv()
    io.sendline(prefix)

pow_handler()


#=============================================================================
# exploit bakflip starting here
#=============================================================================
PROMPT = b"# "
INPUT = ": "
n = NIST192p.order
MAXBIT = 101
MSG = b'message'
MS2 = b'massage'
GETFLAG = b'please_give_me_the_flag'
HASH = lambda msg: int(sha1(msg).hexdigest(), 16)

"""
    Exploit Technique in 4 steps
    1> Recover the Public Key form a message, signature pair
    2> Apply bit flipping attack and recover 70 msbits of the secret
    3> Perform Pollard Lambda with the known bounds on d
    4> Forge the signature with the recovered d
"""

#io = process("./challenge.py")
p = log.progress("Running Exploit")

def signMessage(message: bytes, mask: int) -> str:
    if io.can_recv(): io.recvuntil(PROMPT)
    io.sendline('1')
    io.recvuntil(INPUT)
    io.sendline(message)
    io.recvuntil(INPUT)
    io.sendline(str(mask))
    output = io.recvline()
    return re.findall(r'[0-9a-f]{96}', output.decode()).pop()


def getFlag(forged_signature: bytes):
    if io.can_recv(): io.recvuntil(PROMPT)
    io.sendline('3')
    io.recvuntil(INPUT)
    io.sendline(forged_signature)
    flag = io.recv()
    return flag


# Step 1: Recover Public Key
def recoverPubKey() -> VerifyingKey:
    signature1 = unhexlify(signMessage(MSG, 0))
    signature2 = unhexlify(signMessage(MS2, 0))
    vk_1 = VerifyingKey.from_public_key_recovery(
            signature1,
            MSG,
            curve = NIST192p
    )
    vk_2 = VerifyingKey.from_public_key_recovery(
            signature2,
            MS2,
            curve = NIST192p
    )
    verifyingKey = None
    for key in vk_1:
        if key in vk_2:
            verifyingKey = key
    return verifyingKey


def bitFlipping(Y: Point, G: Point) -> int:
    d = 0
    for idx in trange(MAXBIT-1, 30, -1):
        signature = signMessage(MSG, 1<<idx)
        r, s = map(lambda x: int(x, 16), [signature[:48], signature[48:]])
        s_inv = inverse_mod(s, n)
        u1 = (HASH(MSG) * s_inv) % n
        u2 = (r * s_inv) % n

        T = u1 * G + u2 * Y

        for j in range(0, MAXBIT):
            for sigma in [-1, 1]:
                craft = (sigma * 2**j * r * s_inv) % n
                if (T + craft * G).x() == r:
                    d_j = (1-sigma) // 2
                    d |= d_j * 2**idx
                    break
    #from IPython import embed; embed()
    return d


def pollardLambda(Y: Point, G: Point, d: int, lsb_mask: int) -> int:
    """
    input
    @Y: Pubkey
    @G: Generator
    @d: Msbits for recovered secret_multiplier

    OUTPUT
    @secret_multiplier as the output of pollardLambda algo.
    """
    # NIST192p parameters
    #a = -3
    #b = 2455155546008943817740293915197451784769108058161191238065
    #p = 6277101735386680763835789423207666416083908700390324961279

    a = G.curve().a()
    b = G.curve().b()
    p = G.curve().p()
   
    F = GF(p)
    EC = EllipticCurve([F(a), F(b)])

    GG = EC((G.x(), G.y()))

    YY = EC((Y.x(), Y.y()))

    secret_multiplier = discrete_log_lambda(
        a = YY,
        base = GG,
        bounds = (d, d | 0x7fffffff),
        operation = "+"
    )
    assert YY == secret_multiplier * GG, print("Unsatisfied Result")
    return secret_multiplier


p.status("Recovering Public Key")
pubkey = recoverPubKey()
Y = pubkey.pubkey.point
G = pubkey.pubkey.generator
p.status("Deploying BitFlipping Attack")
d = bitFlipping(Y,G)

p.status("Reconstructing secret with PollardLambda, (this might take a while)")
secret_multiplier = pollardLambda(Y, G, d, 0x7fffffff)
# The recovered d is accurate to 70 msb
print("secret_key: ", secret_multiplier)

p.status("Forging signatures")
signingKey = SigningKey.from_secret_exponent(secret_multiplier)
forged_signature = signingKey.sign(GETFLAG)
flag = getFlag(hexlify(forged_signature))
print(flag)
