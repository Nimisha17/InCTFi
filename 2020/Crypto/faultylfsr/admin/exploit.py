from Crypto.Cipher import AES
from hashlib import sha256
from random import Random
from tqdm import tqdm
from sympy.ntheory import factorint

remdata = list(open("rem_data").read())
remdata = list(map(int,remdata))
masks = [43, 578, 22079, 142962]
SECRET = 14810031

class lfsr():
    def __init__(self, init, mask,masklength):
        self.rand = Random()
        self.rand.seed(SECRET + mask)
        self.init = init
        self.mask = mask
        self.masklength = masklength


    def next(self):
        r  = self.rand.getrandbits(20)
        nextdata = ((self.init << 1)&0xffffff) ^ (self.mask & r)
        #print bin(nextdata)[2:]
        output = 0
        l = nextdata.bit_length()  # St-1
        for i in range(0,l//2,2) :
            output += int(bin(nextdata)[2:][i]) # St-2
            #output+=(nextdata>>(l-i-1))&1
        self.init = nextdata ^ output
        return output%2

#Tried finding an alternative for St-1 and St-2 but couldnt. If this is true the challenge can be solved only through correlation attack 

def combine(a,b,c,d) :
    return (a^b)^(a|c)^(b|c)^(c|d)
    #a==b 75%
    #c^d == out 75%
    #if d!=out => c==1 always

def solve_d() : 
    poss = []
    for i in tqdm(range(2**17 ,2**17 + 2**14)) : #given in the secription the reason for range
        d = lfsr(i,masks[3],masks[3].bit_length())
        ct = 0
        for k in range(160) :
            d.next()
        for j in remdata[:2000] :
            if d.next() == j :
                ct+=1.0
        #if i == 136757 :
        #    print " for the actual seed ct is ",ct
        if ct/2000 >= 0.74 :
            poss.append(i)
            print ((i,ct/2000))
    bd = []
    for i in poss :
        for j in factorint(i).keys() :
            if j.bit_length() == 10 :
                bd.append((j,i))
    return bd


def solve_c() :
    pair = []
    poss_d = solve_d()
    for b,d in tqdm(poss_d) :
        #poss_c = []
        for i in tqdm(range(2**14,2**15)) :
            dt = lfsr(d,masks[3],masks[3].bit_length())
            ct = lfsr(i,masks[2],masks[2].bit_length())
            ct1 =ct2 = 0
            for j in range(160) :
                dt.next()
                ct.next()
            for j in remdata[:2000] :
                dtmp = dt.next()
                ctmp = ct.next()
                if dtmp!=j and ctmp!=1 :
                    break
                if ctmp == j :
                    ct1+=1.0
                if ctmp^dtmp == j :
                    ct2+=1.0
            if i == 17523 :
                print "org",(i,ct1,ct2)

            if ct1/2000 > 0.45 and ct1/2000<0.6 and ct2/2000>0.74 :
                #poss_c.append(i)
                pair.append((b,i,d))
                print (i,ct1/2000,ct2/2000)

    return pair

def solve_rest() : 
    
    res = []
    pair = solve_c()
    for b,c,d in tqdm(pair) :
        for a in range(2**5,2**6) :
            l = [lfsr(i,j,j.bit_length()) for i,j in zip((a,b,c,d),masks)]
            for i in range(160) :
                l[0].next()
                l[1].next()
                l[2].next()
                l[3].next()
            ct = 0
            for i in remdata[:2000] :
                if combine(l[0].next(),l[1].next(),l[2].next(),l[3].next()) == i :

                    ct+=1
                    continue
                else :
                    break
            if ct == 2000 :
                decrypt([a,b,c,d])
    return res

def generate(seeds) :
    masks = [43, 578, 22079, 142962]
    l = [lfsr(seeds[i],masks[i],masks[i].bit_length()) for i in range(4)]
    data = ''
    for i in range(160) :
        data += str(combine(l[0].next(),l[1].next(),l[2].next(),l[3].next()))
    return data


def decrypt(seeds) :
    
    f = open('flag.enc').read()
     
    key = sha256(generate(seeds)).digest()
    flag = AES.new(key,AES.MODE_ECB).decrypt(f)
    if "inctf" in flag :
        print flag
        exit(0)




if __name__ == "__main__" :
    solve_rest()
